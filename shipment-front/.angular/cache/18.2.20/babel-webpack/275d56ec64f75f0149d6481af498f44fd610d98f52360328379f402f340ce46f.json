{"ast":null,"code":"import { __decorate } from \"tslib\";\nimport { Component } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { FormsModule } from '@angular/forms';\nlet ManifestComponent = class ManifestComponent {\n  // Open edit popup\n  openEditPopup(manifest) {\n    this.selectedManifest = JSON.parse(JSON.stringify(manifest || {}));\n    this.editManifestRows = this.buildEditManifestRows(this.selectedManifest);\n    this.showEditPopup = true;\n  }\n  // Close edit popup\n  closeEditPopup() {\n    this.showEditPopup = false;\n    this.selectedManifest = null;\n    this.editManifestRows = [];\n  }\n  // Save edits\n  finalizeEdit() {\n    if (!this.selectedManifest) return;\n    const email = localStorage.getItem('email') || '';\n    if (!this.validateEditManifestRows()) {\n      alert('Please fix manifest quantities that exceed the consignment product quantity.');\n      return;\n    }\n    // Update manifest in DB\n    this.http.post(`http://localhost:3000/api/manifest/manifestationNumber`, this.selectedManifest).subscribe({\n      next: () => {\n        console.log('âœ… Manifest updated in DDDDDDDDDB', this.selectedManifest.consignments);\n        this.selectedManifest.consignments.forEach(cons => {\n          this.updateConsignment(this.username, cons);\n        });\n        console.log('âœ… Manifest updated successfully');\n        alert('Manifest updated!');\n        this.loadManifests(); // reload list\n        this.closeEditPopup();\n      },\n      error: err => console.error('âŒ Error updating manifest:', err)\n    });\n  }\n  constructor(http) {\n    this.http = http;\n    this.allManifests = [];\n    this.manifests = [];\n    this.filteredManifests = [];\n    this.searchText = '';\n    this.filterDate = '';\n    this.filterConsignor = '';\n    this.selectedManifest = null;\n    this.showDeliveryPopup = false;\n    this.selectedForDelivery = [];\n    this.email = '';\n    this.username = '';\n    this.branch = localStorage.getItem('branch') || 'All Branches';\n    this.showCancelPopup = false;\n    this.selectedForCancel = [];\n    this.showEditPopup = false;\n    this.editManifestRows = [];\n  }\n  ngOnInit() {\n    this.email = localStorage.getItem('email') || '';\n    this.username = localStorage.getItem('username') || '';\n    this.branch = localStorage.getItem('branch') || 'All Branches';\n    this.loadManifests();\n    this.branchCheck = setInterval(() => {\n      const current = localStorage.getItem('branch') || 'All Branches';\n      if (current !== this.branch) {\n        this.branch = current;\n        this.loadManifests();\n      }\n    }, 1000);\n  }\n  // âœ… Load all manifests from backend\n  loadManifests() {\n    this.http.get('http://localhost:3000/api/manifest', {\n      params: {\n        email: localStorage.getItem('email') || '',\n        branch: localStorage.getItem('branch') || ''\n      }\n    }).subscribe({\n      next: res => {\n        this.allManifests = res.filter(item => item.mshipmentStatus != 'Cancelled');\n        this.manifests = res.filter(item => item.mshipmentStatus != 'Delivered' && item.mshipmentStatus != 'Cancelled').sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());\n        this.filteredManifests = [...this.manifests];\n      },\n      error: err => console.error('âŒ Error loading shipments:', err)\n    });\n  }\n  applyFilters() {\n    this.filteredManifests = this.manifests.filter(m => (this.searchText ? m.manifestationNumber?.includes(this.searchText) || m.consignments?.some(c => c.consignor?.includes(this.searchText)) : true) && (this.filterDate ? new Date(m.date).toISOString().split('T')[0] === this.filterDate : true) && (this.filterConsignor ? m.consignments?.some(c => c.consignor?.toLowerCase().includes(this.filterConsignor.toLowerCase())) : true));\n  }\n  toggleAllSelection(event) {\n    const checked = event.target.checked;\n    this.filteredManifests.forEach(m => m.selected = checked);\n  }\n  // âœ… Open delivery popup\n  openDeliveryPopup() {\n    if (this.branch === 'All Branches') {\n      alert('Please select a specific branch before confirming delivery.');\n      return;\n    }\n    this.selectedForDelivery = this.filteredManifests.filter(m => m.selected);\n    if (this.selectedForDelivery.length === 0) {\n      alert('âš ï¸ Please select at least one manifest to deliver.');\n      return;\n    }\n    this.showDeliveryPopup = true;\n  }\n  closeDeliveryPopup() {\n    this.showDeliveryPopup = false;\n  }\n  // âœ… Finalize delivery and update statuses in both DBs\n  finalizeDelivery() {\n    if (this.branch === 'All Branches') {\n      alert('Please select a specific branch before confirming delivery.');\n      return;\n    }\n    if (this.selectedForDelivery.length === 0) {\n      alert('No manifests selected for delivery.');\n      return;\n    }\n    const userEmail = localStorage.getItem('email') || '';\n    this.selectedForDelivery.forEach(manifest => {\n      manifest.consignments.forEach(cons => {\n        // Update product delivery status\n        cons.invoices.forEach(inv => {\n          inv.products.forEach(p => {\n            const deliveredQty = Number(p.intransitstock) || 0;\n            if (deliveredQty > 0) {\n              p.deliveredstock = (p.deliveredstock || 0) + deliveredQty;\n              p.manifestQty = deliveredQty;\n            }\n            p.intransitstock = 0;\n          });\n        });\n        // Check if all products are fully delivered\n        const allDelivered = cons.invoices.every(inv => inv.products.every(p => (Number(p.deliveredstock) || 0) >= (Number(p.amount) || 0) || (Number(p.instock) || 0) === 0 && (Number(p.intransitstock) || 0) === 0));\n        // Prepare updated consignment\n        console.log(`ðŸšš Updating consignment1  to status:`, allDelivered);\n        const updatedConsignment = {\n          ...cons,\n          mshipmentStatus: 'Delivered'\n        };\n        console.log(`ðŸšš Updating consignment1  to status:`, updatedConsignment.mshipmentStatus);\n        // Send updated consignment using helper method\n        this.updateConsignment(this.username, updatedConsignment);\n      });\n      manifest = {\n        ...manifest,\n        mshipmentStatus: 'Delivered'\n      };\n      console.log(`ðŸšš Updating consignment ${manifest.manifestationNumber} to status:`, manifest);\n      this.http.post(`http://localhost:3000/api/manifest/manifestationNumber`, manifest).subscribe({\n        next: () => {\n          console.log('âœ… Manifest Stock updated');\n        },\n        error: err => console.error('âŒ Error updating stock:', err)\n      });\n    });\n    // Final UI updates\n    this.showDeliveryPopup = false;\n    alert('âœ… Delivery completed successfully!');\n    this.filteredManifests.forEach(m => m.selected = false);\n    this.loadManifests();\n  }\n  updatedstkConsignmentfn(updatedConsignment) {\n    this.http.put(`http://localhost:3000/api/newshipments/${updatedConsignment.consignmentNumber}`, updatedConsignment).subscribe({\n      next: () => {\n        console.log('âœ… Stock updated');\n      },\n      error: err => console.error('âŒ Error updating stock:', err)\n    });\n  }\n  updateConsignment(username, updatedConsignment) {\n    const items = [];\n    (updatedConsignment.invoices || []).forEach(inv => {\n      (inv.products || []).forEach(p => {\n        const type = String(p.type || '').trim();\n        const qty = Number(p.manifestQty) || 0;\n        if (!type || qty <= 0) return;\n        items.push({\n          type,\n          qty\n        });\n      });\n    });\n    if (!items.length) return;\n    const payload = {\n      consignmentNumber: updatedConsignment.consignmentNumber,\n      items\n    };\n    this.http.post('http://localhost:3000/api/newshipments/deliver', payload).subscribe({\n      next: () => {\n        this.loadManifests();\n      },\n      error: err => console.error('Error updating delivery:', err)\n    });\n  }\n  openCancelPopup() {\n    this.selectedForCancel = this.filteredManifests.filter(m => m.selected);\n    if (this.selectedForCancel.length === 0) {\n      alert('âš ï¸ Please select at least one manifest to cancel.');\n      return;\n    }\n    this.showCancelPopup = true;\n  }\n  closeCancelPopup() {\n    this.showCancelPopup = false;\n  }\n  // âœ… Finalize cancellation\n  finalizeCancel() {\n    if (this.selectedForCancel.length === 0) {\n      alert('No manifests selected for cancellation.');\n      return;\n    }\n    const userEmail = this.email;\n    this.selectedForCancel.forEach(manifest => {\n      // Update consignments in newshipments DB\n      manifest.consignments.forEach(cons => {\n        const updatedConsignment = {\n          ...cons,\n          shipmentStatus: 'Pending'\n        };\n        this.updateConsignment(this.username, updatedConsignment);\n      });\n      // Update manifest in manifest DB\n      const cancelledManifest = {\n        ...manifest,\n        mshipmentStatus: 'Cancelled'\n      };\n      this.http.post(`http://localhost:3000/api/manifest/manifestationNumber`, cancelledManifest).subscribe({\n        next: () => {\n          manifest.consignments.forEach(cons => {\n            console.log(`ðŸ—‘ï¸ Manifest ${manifest.manifestationNumber} cancelled`, cons);\n            this.http.get('http://localhost:3000/api/newshipments/getConsignment', {\n              params: {\n                email: localStorage.getItem('email') || '',\n                consignmentNumber: cons.consignmentNumber\n              }\n            }).subscribe({\n              next: res => {\n                let stkupdatedConsignment = res[0];\n                console.log('Manifest cancelled', stkupdatedConsignment);\n                const cancelQtyByType = new Map();\n                (cons.invoices || []).forEach(inv => {\n                  (inv.products || []).forEach(p => {\n                    const key = String(p.type || '').trim();\n                    if (!key) return;\n                    const qty = Number(p.manifestQty) || 0;\n                    if (qty <= 0) return;\n                    cancelQtyByType.set(key, (cancelQtyByType.get(key) || 0) + qty);\n                  });\n                });\n                stkupdatedConsignment.invoices?.forEach(invoice => {\n                  invoice.products?.forEach(product => {\n                    const key = String(product.type || '').trim();\n                    const qty = cancelQtyByType.get(key) || 0;\n                    if (!qty) return;\n                    product.intransitstock = Math.max(0, (Number(product.intransitstock) || 0) - qty);\n                    product.instock = (Number(product.instock) || 0) + qty;\n                  });\n                });\n                // Check if all products are fully delivered\n                const allDelivered = stkupdatedConsignment.invoices.every(inv => inv.products.every(p => p.deliveredstock != 0));\n                // Prepare updated consignment\n                console.log(`ðŸ—‘ï¸ Manifest2 cancelled`, allDelivered);\n                stkupdatedConsignment.shipmentStatus = allDelivered ? 'Pending' : 'In Transit/Pending';\n                this.updatedstkConsignmentfn(stkupdatedConsignment);\n              },\n              error: err => console.error('âŒ Error loading shipments:', err)\n            });\n          });\n          // Additional logic for finding the consignments and updating the newshipment respectively\n        },\n        error: err => console.error('âŒ Error cancelling manifest:', err)\n      });\n    });\n    this.showCancelPopup = false;\n    alert('ðŸ—‘ï¸ Cancellation completed successfully!');\n    this.filteredManifests.forEach(m => m.selected = false);\n    this.loadManifests();\n  }\n  //Printing the manifest\n  printManifest() {\n    const selected = this.filteredManifests?.filter(m => m.selected) || [];\n    if (selected.length === 0) {\n      alert('No manifests selected.');\n      return;\n    }\n    fetch('assets/manifest-template.html').then(res => res.text()).then(template => {\n      let fullHtml = `\n        <html>\n          <head>\n            <style>\n              body { font-family: Arial, sans-serif; padding: 20px; }\n              h2 { margin-bottom: 0; }\n              table { width: 100%; border-collapse: collapse; margin-top: 10px; }\n              th, td { border: 1px solid #ccc; padding: 8px; text-align: left; }\n              th { background-color: #f2f2f2; }\n              .page-break { page-break-after: always; }\n            </style>\n          </head>\n          <body>\n      `;\n      selected.forEach((manifest, index) => {\n        // Build rows for consignments/invoices/products\n        const rows = manifest.consignments.flatMap(c => c.invoices.flatMap(inv => inv.products.map(p => `\n              <tr>\n                <td>${manifest.manifestationNumber}</td>\n                <td>${manifest.mshipmentStatus}</td>\n                <td>${manifest.date}</td>\n                <td>${c.consignmentNumber}</td>\n                <td>${c.consignor}</td>\n                <td>${inv.number}</td>\n                <td>${p.type}</td>\n                <td>${p.manifestQty}</td>\n                <td>${p.instock}</td>\n                <td>${inv.value}</td>\n                <td>${manifest.branch}</td>\n              </tr>\n            `))).join('');\n        // Replace placeholders in template\n        const htmlContent = template.replace('{{manifestNumber}}', manifest.manifestationNumber).replace('{{status}}', manifest.mshipmentStatus).replace('{{date}}', manifest.date).replace('{{branch}}', manifest.branch).replace('{{rows}}', rows);\n        fullHtml += htmlContent;\n        // Add page break after each manifest except the last\n        if (index < selected.length - 1) {\n          fullHtml += `<div class=\"page-break\"></div>`;\n        }\n      });\n      fullHtml += `</body></html>`;\n      const printWindow = window.open('', '_blank');\n      if (printWindow) {\n        printWindow.document.open();\n        printWindow.document.write(fullHtml); // âœ… safer than body.innerHTML\n        printWindow.document.close();\n        printWindow.print();\n      }\n    }).catch(err => console.error('Error loading manifest template:', err));\n  }\n  normalizeKey(value) {\n    return String(value || '').trim().toLowerCase();\n  }\n  getOtherManifestedQty(manifestNumber, consignmentNumber, invoiceNumber, productType) {\n    const targetConsignment = this.normalizeKey(consignmentNumber);\n    const targetInvoice = this.normalizeKey(invoiceNumber);\n    const targetProduct = this.normalizeKey(productType);\n    if (!targetConsignment || !targetProduct) return 0;\n    let total = 0;\n    (this.allManifests || []).forEach(manifest => {\n      if (String(manifest.manifestationNumber) === String(manifestNumber)) return;\n      (manifest.consignments || []).forEach(cons => {\n        if (this.normalizeKey(cons.consignmentNumber) !== targetConsignment) return;\n        (cons.invoices || []).forEach(inv => {\n          if (targetInvoice && this.normalizeKey(inv.number) !== targetInvoice) return;\n          (inv.products || []).forEach(prod => {\n            if (this.normalizeKey(prod.type) !== targetProduct) return;\n            total += Number(prod.manifestQty) || 0;\n          });\n        });\n      });\n    });\n    return total;\n  }\n  buildEditManifestRows(manifest) {\n    const rows = [];\n    const manifestNumber = manifest?.manifestationNumber;\n    (manifest?.consignments || []).forEach(cons => {\n      (cons.invoices || []).forEach(inv => {\n        (inv.products || []).forEach(prod => {\n          const otherManifested = this.getOtherManifestedQty(manifestNumber, cons.consignmentNumber, inv.number, prod.type);\n          const amount = Number(prod.amount) || 0;\n          const currentQty = Number(prod.manifestQty) || 0;\n          const row = {\n            consignmentNumber: cons.consignmentNumber,\n            invoiceNumber: inv.number,\n            productType: prod.type,\n            instock: Number(prod.instock) || 0,\n            delivered: Number(prod.deliveredstock) || 0,\n            amount,\n            otherManifested,\n            productRef: prod,\n            maxAllowed: Math.max(0, amount - otherManifested),\n            totalManifested: otherManifested + currentQty\n          };\n          rows.push(row);\n        });\n      });\n    });\n    return rows;\n  }\n  onManifestQtyChange(row) {\n    if (!row || !row.productRef) return;\n    let qty = Number(row.productRef.manifestQty);\n    if (!Number.isFinite(qty) || qty < 0) qty = 0;\n    const amount = Number(row.amount) || 0;\n    const otherManifested = Number(row.otherManifested) || 0;\n    const maxAllowed = Math.max(0, amount - otherManifested);\n    if (qty > maxAllowed) {\n      qty = maxAllowed;\n    }\n    row.productRef.manifestQty = qty;\n    row.maxAllowed = maxAllowed;\n    row.totalManifested = otherManifested + qty;\n  }\n  isRowOverLimit(row) {\n    if (!row) return false;\n    return (Number(row.totalManifested) || 0) > (Number(row.amount) || 0);\n  }\n  hasOverManifestLimit() {\n    return (this.editManifestRows || []).some(row => this.isRowOverLimit(row));\n  }\n  validateEditManifestRows() {\n    let valid = true;\n    this.editManifestRows.forEach(row => {\n      const amount = Number(row.amount) || 0;\n      const otherManifested = Number(row.otherManifested) || 0;\n      const current = Number(row.productRef?.manifestQty) || 0;\n      const total = otherManifested + current;\n      row.totalManifested = total;\n      row.maxAllowed = Math.max(0, amount - otherManifested);\n      if (total > amount) valid = false;\n    });\n    return valid;\n  }\n};\nManifestComponent = __decorate([Component({\n  selector: 'app-manifest',\n  standalone: true,\n  imports: [CommonModule, FormsModule],\n  templateUrl: './manifest.component.html',\n  styleUrls: ['./manifest.component.css']\n})], ManifestComponent);\nexport { ManifestComponent };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}